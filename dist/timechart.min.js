!function(t,e){"object"==typeof exports&&"undefined"!=typeof module?module.exports=e(require("d3-color"),require("d3-scale"),require("d3-axis"),require("d3-selection")):"function"==typeof define&&define.amd?define(["d3-color","d3-scale","d3-axis","d3-selection"],e):(t=t||self).TimeChart=e(t.d3,t.d3,t.d3,t.d3)}(this,(function(t,e,i,n){"use strict";function s(t,e,i,n,s){if(e>=i)return e;if(n<=s(t[e]))return e;if(n>s(t[i-1]))return i;for(i-=1;e+1<i;){const o=s(t[e]),a=s(t[i]),r=a<=o?0:(n-o)/(a-o);let h=Math.ceil(e+r*(i-e));h===i?h--:h===e&&h++,s(t[h])<n?e=h:i=h}return i}class o{constructor(){this.callbacks=[]}on(t){this.callbacks.push(t)}dispatch(...t){for(const e of this.callbacks)e(...t)}}class a{constructor(t){this.options=t,this.xScale=e.scaleLinear(),this.yScale=e.scaleLinear(),this.xRange=null,this.yRange=null,this.seriesInfo=new Map,this.updated=new o,this.redrawRequested=!1,"auto"!==t.xRange&&t.xRange&&this.xScale.domain([t.xRange.min,t.xRange.max]),"auto"!==t.yRange&&t.yRange&&this.yScale.domain([t.yRange.min,t.yRange.max])}resize(t,e){const i=this.options;this.xScale.range([i.paddingLeft,t-i.paddingRight]),this.yScale.range([e-i.paddingBottom,i.paddingTop])}update(){var t,e;for(const t of this.options.series)this.seriesInfo.has(t)||this.seriesInfo.set(t,{yRangeUpdatedIndex:0});const i=this.options.series.filter(t=>t.data.length>0);if(0===i.length)return;const n=this.options.xRange,s=this.options.yRange;{const s=Math.max(...i.map(t=>t.data[t.data.length-1].x)),o=null!=(e=null===(t=this.xRange)||void 0===t?void 0:t.min)?e:Math.min(...i.map(t=>t.data[0].x));if(this.xRange={max:s,min:o},this.options.realTime||"auto"===n)if(this.options.realTime){const t=this.xScale.domain(),e=t[1]-t[0];this.xScale.domain([s-e,s])}else this.xScale.domain([o,s]);else n&&this.xScale.domain([n.min,n.max])}{const t=i.map(t=>function(t){let e=-1/0,i=1/0;for(const n of t)n>e&&(e=n),n<i&&(i=n);return{max:e,min:i}}(t.data.slice(this.seriesInfo.get(t).yRangeUpdatedIndex).map(t=>t.y)));this.yRange&&t.push(this.yRange);const e=Math.min(...t.map(t=>t.min)),n=Math.max(...t.map(t=>t.max));if(this.yRange={max:n,min:e},"auto"===s){this.yScale.domain([e,n]).nice();for(const t of i)this.seriesInfo.get(t).yRangeUpdatedIndex=t.data.length}else s&&this.yScale.domain([s.min,s.max])}this.updated.dispatch()}requestRedraw(){this.redrawRequested||(this.redrawRequested=!0,requestAnimationFrame(t=>{this.redrawRequested=!1,this.update()}))}}var r="undefined"!=typeof Float32Array?Float32Array:Array;function h(){var t=new r(16);return r!=Float32Array&&(t[1]=0,t[2]=0,t[3]=0,t[4]=0,t[6]=0,t[7]=0,t[8]=0,t[9]=0,t[11]=0,t[12]=0,t[13]=0,t[14]=0),t[0]=1,t[5]=1,t[10]=1,t[15]=1,t}function c(t,e,i){var n=e[0],s=e[1],o=e[2],a=e[3],r=e[4],h=e[5],c=e[6],l=e[7],d=e[8],u=e[9],m=e[10],p=e[11],g=e[12],f=e[13],x=e[14],y=e[15],v=i[0],w=i[1],R=i[2],A=i[3];return t[0]=v*n+w*r+R*d+A*g,t[1]=v*s+w*h+R*u+A*f,t[2]=v*o+w*c+R*m+A*x,t[3]=v*a+w*l+R*p+A*y,v=i[4],w=i[5],R=i[6],A=i[7],t[4]=v*n+w*r+R*d+A*g,t[5]=v*s+w*h+R*u+A*f,t[6]=v*o+w*c+R*m+A*x,t[7]=v*a+w*l+R*p+A*y,v=i[8],w=i[9],R=i[10],A=i[11],t[8]=v*n+w*r+R*d+A*g,t[9]=v*s+w*h+R*u+A*f,t[10]=v*o+w*c+R*m+A*x,t[11]=v*a+w*l+R*p+A*y,v=i[12],w=i[13],R=i[14],A=i[15],t[12]=v*n+w*r+R*d+A*g,t[13]=v*s+w*h+R*u+A*f,t[14]=v*o+w*c+R*m+A*x,t[15]=v*a+w*l+R*p+A*y,t}function l(t,e){return t[0]=1,t[1]=0,t[2]=0,t[3]=0,t[4]=0,t[5]=1,t[6]=0,t[7]=0,t[8]=0,t[9]=0,t[10]=1,t[11]=0,t[12]=e[0],t[13]=e[1],t[14]=e[2],t[15]=1,t}function d(t,e){return t[0]=e[0],t[1]=0,t[2]=0,t[3]=0,t[4]=0,t[5]=e[1],t[6]=0,t[7]=0,t[8]=0,t[9]=0,t[10]=e[2],t[11]=0,t[12]=0,t[13]=0,t[14]=0,t[15]=1,t}function u(){var t=new r(3);return r!=Float32Array&&(t[0]=0,t[1]=0,t[2]=0),t}Math.hypot||(Math.hypot=function(){for(var t=0,e=arguments.length;e--;)t+=arguments[e]*arguments[e];return Math.sqrt(t)});var m;m=u();function p(){var t=new r(2);return r!=Float32Array&&(t[0]=0,t[1]=0),t}var g;!function(){var t=p()}();function f(t,e,i){var n;const s=x(t.createShader(e));if(t.shaderSource(s,i),t.compileShader(s),!t.getShaderParameter(s,t.COMPILE_STATUS)){const e=null!=(n=t.getShaderInfoLog(s))?n:"Unknown Error.";throw t.deleteShader(s),new Error(e)}return s}function x(t){if(!t)throw new Error("value must not be falsy");return t}function y(e){const i=t.rgb(e);return[i.r/255,i.g/255,i.b/255,i.opacity]}!function(t){t[t.DATA_POINT=0]="DATA_POINT",t[t.DIR=1]="DIR"}(g||(g={}));const v=`#version 300 es\nlayout (location = ${g.DATA_POINT}) in vec2 aDataPoint;\nlayout (location = ${g.DIR}) in vec2 aDir;\n\nuniform mat4 uModelViewMatrix;\nuniform mat4 uProjectionMatrix;\nuniform float uLineWidth;\n\nvoid main() {\n    vec4 cssPose = uModelViewMatrix * vec4(aDataPoint, 0.0, 1.0);\n    vec4 dir = uModelViewMatrix * vec4(aDir, 0.0, 0.0);\n    dir = normalize(dir);\n    gl_Position = uProjectionMatrix * (cssPose + vec4(-dir.y, dir.x, 0.0, 0.0) * uLineWidth);\n}\n`;class w extends class{constructor(t,e,i){var n;this.gl=t;const s=x(t.createProgram());if(t.attachShader(s,x(f(t,t.VERTEX_SHADER,e))),t.attachShader(s,x(f(t,t.FRAGMENT_SHADER,i))),t.linkProgram(s),!t.getProgramParameter(s,t.LINK_STATUS)){const e=null!=(n=t.getProgramInfoLog(s))?n:"Unknown Error.";throw t.deleteProgram(s),new Error(e)}this.program=s}use(){this.gl.useProgram(this.program)}}{constructor(t){super(t,v,"#version 300 es\nprecision lowp float;\n\nuniform vec4 uColor;\n\nout vec4 outColor;\n\nvoid main() {\n    outColor = uColor;\n}\n"),this.locations={uModelViewMatrix:x(t.getUniformLocation(this.program,"uModelViewMatrix")),uProjectionMatrix:x(t.getUniformLocation(this.program,"uProjectionMatrix")),uLineWidth:x(t.getUniformLocation(this.program,"uLineWidth")),uColor:x(t.getUniformLocation(this.program,"uColor"))}}}const R=4*Float32Array.BYTES_PER_ELEMENT;class A{constructor(t,e,i){this.gl=t,this.dataPoints=e,this.firstDataPointIndex=i,this.length=0,this.vao=x(t.createVertexArray()),this.bind(),this.dataBuffer=x(t.createBuffer()),t.bindBuffer(t.ARRAY_BUFFER,this.dataBuffer),t.bufferData(t.ARRAY_BUFFER,2097160*Float32Array.BYTES_PER_ELEMENT,t.DYNAMIC_DRAW),t.enableVertexAttribArray(g.DATA_POINT),t.vertexAttribPointer(g.DATA_POINT,2,t.FLOAT,!1,R,0),t.enableVertexAttribArray(g.DIR),t.vertexAttribPointer(g.DIR,2,t.FLOAT,!1,R,2*Float32Array.BYTES_PER_ELEMENT)}bind(){this.gl.bindVertexArray(this.vao)}clear(){this.length=0}delete(){this.clear(),this.gl.deleteBuffer(this.dataBuffer),this.gl.deleteVertexArray(this.vao)}addDataPoints(){const t=this.dataPoints,e=this.firstDataPointIndex+this.length,i=131072-this.length,n=t.length-e,s=i<n,o=s?i:n;let a=16*o;s&&(a+=8);const r=new Float32Array(a);let h=0;const c=p(),l=p(),d=p(),u=p();function m(t,e){var i,n,s;c[0]=t.x,c[1]=t.y,l[0]=e.x,l[1]=e.y,n=c,s=l,(i=d)[0]=n[0]-s[0],i[1]=n[1]-s[1],function(t,e){var i=e[0],n=e[1],s=i*i+n*n;s>0&&(s=1/Math.sqrt(s)),t[0]=e[0]*s,t[1]=e[1]*s}(d,d),function(t,e){t[0]=-e[0],t[1]=-e[1]}(u,d)}function g(t){r[h]=t[0],r[h+1]=t[1],h+=2}let f=t[e-1];for(let i=0;i<o;i++){const n=t[e+i];m(n,f),f=n;for(const t of[l,c])for(const e of[d,u])g(t),g(e)}if(s){m(t[e+o],f);for(const t of[d,u])g(l),g(t)}const x=this.gl;return x.bindBuffer(x.ARRAY_BUFFER,this.dataBuffer),x.bufferSubData(x.ARRAY_BUFFER,4*R*this.length,r),this.length+=o,e+o}draw(t){const e=Math.max(0,t.min-this.firstDataPointIndex),i=Math.min(this.length,t.max-this.firstDataPointIndex)-e,n=this.gl;this.bind(),n.drawArrays(n.TRIANGLE_STRIP,4*e,4*i)}}class b{constructor(t,e){this.gl=t,this.series=e,this.vertexArrays=[]}syncBuffer(){let t,e=1;const i=()=>{t=new A(this.gl,this.series.data,e),this.vertexArrays.push(t)};if(this.vertexArrays.length>0){const i=this.vertexArrays[this.vertexArrays.length-1];if(e=i.firstDataPointIndex+i.length,e>this.series.data.length)throw new Error("remove data unsupported.");if(e===this.series.data.length)return;t=i}else{if(!(this.series.data.length>=2))return;i(),t=t}for(;;){if(e=t.addDataPoints(),e>=this.series.data.length){if(e>this.series.data.length)throw Error("Assertion failed.");break}i()}}draw(t){const e=this.series.data;if(0===e.length||e[0].x>t.max||e[e.length-1].x<t.min)return;const i=t=>t.x,n=s(e,1,e.length,t.min,i),o=s(e,n,e.length-1,t.max,i)+1,a=Math.floor((n-1)/131072),r=Math.ceil((o-1)/131072),h={min:n,max:o};for(let t=a;t<r;t++)this.vertexArrays[t].draw(h)}}class M{constructor(t,e,i){this.model=t,this.gl=e,this.options=i,this.program=new w(this.gl),this.arrays=new Map,this.height=0,this.width=0,t.updated.on(()=>this.drawFrame()),this.program.use()}syncBuffer(){for(const t of this.options.series){let e=this.arrays.get(t);e||(e=new b(this.gl,t),this.arrays.set(t,e)),e.syncBuffer()}}onResize(t,e){this.height=e,this.width=t;const i=(n=t,s=e,(o=new r(2))[0]=n,o[1]=s,o);var n,s,o;!function(t,e,i){t[0]=e[0]/i[0],t[1]=e[1]/i[1]}(i,i,[2,2]),function(t,e){t[0]=1/e[0],t[1]=1/e[1]}(i,i);const a=h();l(a,[-1,-1,0]);const u=h();d(u,[...i,1]),c(u,a,u),this.gl.uniformMatrix4fv(this.program.locations.uProjectionMatrix,!1,u)}drawFrame(){var t;this.syncBuffer(),this.syncDomain();const e=this.gl;for(const[i,n]of this.arrays){const s=y(i.color);e.uniform4fv(this.program.locations.uColor,s);const o=null!=(t=i.lineWidth)?t:this.options.lineWidth;e.uniform1f(this.program.locations.uLineWidth,o/2);const a={min:this.model.xScale.invert(-o/2),max:this.model.xScale.invert(this.width+o/2)};n.draw(a)}}ySvgToCanvas(t){return-t+this.height}syncDomain(){const t=this.model,e=this.gl,i=[t.xScale(0),this.ySvgToCanvas(t.yScale(0)),0],n=[t.xScale(1),this.ySvgToCanvas(t.yScale(1)),0],s=h(),o=u();var a,r,m;r=n,m=i,(a=o)[0]=r[0]-m[0],a[1]=r[1]-m[1],a[2]=r[2]-m[2],d(s,o);const p=h();l(p,i),c(s,p,s),e.uniformMatrix4fv(this.program.locations.uModelViewMatrix,!1,s)}}class P{constructor(t,e,i){i.updated.on(()=>this.clear()),t.style.position="relative";const n=document.createElement("canvas");n.style.width="100%",n.style.height="100%",n.style.position="absolute",t.appendChild(n);const s=n.getContext("webgl2");if(!s)throw new Error("Unable to initialize WebGL. Your browser or machine may not support it.");const o=s;this.gl=o;const a=y(e.backgroundColor);o.clearColor(...a),this.canvas=n}onResize(){const t=this.canvas,e=window.devicePixelRatio;t.width=t.clientWidth*e,t.height=t.clientHeight*e,this.gl.viewport(0,0,t.width,t.height)}clear(){const t=this.gl;t.clear(t.COLOR_BUFFER_BIT)}}class E{constructor(t,e,s){this.options=e,this.model=s,this.xAxis=i.axisBottom(this.model.xScale),this.yAxis=i.axisLeft(this.model.yScale),s.updated.on(()=>this.update()),t.style.position="relative";const o=n.select(t).append("svg").style("position","absolute").style("width","100%").style("height","100%");this.svgNode=o.node(),this.xg=o.append("g"),this.yg=o.append("g")}update(){const t=this.model.xScale,i=e.scaleTime().domain(t.domain().map(t=>t+this.options.baseTime)).range(t.range());this.xAxis.scale(i),this.xg.call(this.xAxis),this.yAxis.scale(this.model.yScale),this.yg.call(this.yAxis)}onResize(){const t=this.svgNode,e=this.options;this.xg.attr("transform",`translate(0, ${t.clientHeight-e.paddingBottom})`),this.yg.attr("transform",`translate(${e.paddingLeft}, 0)`),this.update()}}function D(t){const e=t.domain(),i=t.range();return(e[1]-e[0])/(i[1]-i[0])}function S(t,e){const i=e[1]-e[0],n=t.scale.domain();if((n[1]-n[0])*i<=0)return!1;const s=Math.min(t.maxDomainExtent,t.maxDomain-t.minDomain,Math.max(t.minDomainExtent,i)),o=(s-i)/2;e[0]-=o,e[1]+=o;const a=Math.min(Math.max(t.minDomain-e[0],0),t.maxDomain-e[1]);e[0]+=a,e[1]+=a;const r=1e-6*s;return t.scale.domain(e),!!function(...t){return[...t[0]].map((e,i)=>t.map(t=>t[i]))}(e,n).some(([t,e])=>Math.abs(t-e)>r)}function T(t,e,i){return t>i?i:t<e?e:t}var L;function U(t){return[{dir:L.X,op:t.x},{dir:L.Y,op:t.y}].filter(t=>void 0!==t.op)}!function(t){t[t.UNKNOWN=0]="UNKNOWN",t[t.X=1]="X",t[t.Y=2]="Y"}(L||(L={}));class I{constructor(t,e){this.el=t,this.options=e,this.scaleUpdated=new o,this.majorDirection=L.UNKNOWN,this.previousPoints=new Map,this.enabled={[L.X]:!1,[L.Y]:!1},t.addEventListener("touchstart",t=>this.onTouchStart(t),{passive:!0}),t.addEventListener("touchend",t=>this.onTouchEnd(t),{passive:!0}),t.addEventListener("touchcancel",t=>this.onTouchEnd(t),{passive:!0}),t.addEventListener("touchmove",t=>this.onTouchMove(t),{passive:!0}),this.update()}update(){this.syncEnabled(),this.syncTouchAction()}syncEnabled(){for(const{dir:t,op:e}of U(this.options))if(e){const i=e.scale.domain().sort();this.enabled[t]=e.minDomain<i[0]&&i[1]<e.maxDomain}else this.enabled[t]=!1}syncTouchAction(){const t=[];this.enabled[L.X]||t.push("pan-x"),this.enabled[L.Y]||t.push("pan-y"),0===t.length&&t.push("none"),this.el.style.touchAction=t.join(" ")}calcKB(t,e,i){if(t===this.majorDirection&&i.length>=2){const t=e.scale.domain(),n=t[1]-t[0];if(function(t){const e=t.reduce((t,e)=>t+e)/t.length;return t.map(t=>(t-e)**2).reduce((t,e)=>t+e)/t.length}(i.map(t=>t.domain))>1e-4*n*n)return function(t){let e=0,i=0,n=0,s=0;const o=t.length;for(const o of t)e+=o.x,i+=o.y,n+=o.x*o.y,s+=o.x*o.x;const a=o*s-e*e,r=0===a?0:(o*n-e*i)/a;return{k:r,b:(i-r*e)/o}}(i.map(t=>({x:t.current,y:t.domain})))}const n=D(e.scale),s=i.map(t=>t.domain-n*t.current).reduce((t,e)=>t+e)/i.length;return{k:n,b:s}}touchPoints(t){const e=this.el.getBoundingClientRect(),i=new Map([...t].map(t=>[t.identifier,{[L.X]:t.clientX-e.left,[L.Y]:t.clientY-e.top}]));let n=!1;for(const{dir:t,op:e}of U(this.options)){const s=e.scale,o=[...i.entries()].map(([e,i])=>({current:i[t],previousPoint:this.previousPoints.get(e)})).filter(t=>void 0!==t.previousPoint).map(({current:e,previousPoint:i})=>({current:e,domain:s.invert(i[t])}));if(0===o.length)continue;const{k:a,b:r}=this.calcKB(t,e,o);S(e,s.range().map(t=>r+a*t))&&(n=!0)}return this.previousPoints=i,n&&this.scaleUpdated.dispatch(),n}dirOptions(t){return{[L.X]:this.options.x,[L.Y]:this.options.y}[t]}onTouchStart(t){if(this.majorDirection===L.UNKNOWN&&t.touches.length>=2){const i=[...t.touches];function e(t){const e=t.reduce((t,e)=>t+e)/t.length;return t.map(t=>(t-e)**2).reduce((t,e)=>t+e)}const n=e(i.map(t=>t.clientX)),s=e(i.map(t=>t.clientY));this.majorDirection=n>s?L.X:L.Y,void 0===this.dirOptions(this.majorDirection)&&(this.majorDirection=L.UNKNOWN)}this.touchPoints(t.touches)}onTouchEnd(t){t.touches.length<2&&(this.majorDirection=L.UNKNOWN),this.touchPoints(t.touches)}onTouchMove(t){this.touchPoints(t.touches)}}class N{constructor(t,e){this.el=t,this.options=e,this.scaleUpdated=new o,t.addEventListener("wheel",t=>this.onWheel(t))}onWheel(t){t.preventDefault();let e=t.deltaX,i=t.deltaY;switch(t.deltaMode){case 1:e*=30,i*=30;break;case 2:e*=400,i*=400}const n={[L.X]:{translate:0,zoom:0},[L.Y]:{translate:0,zoom:0}};t.ctrlKey?t.altKey?(n[L.X].zoom=e,n[L.Y].zoom=i):n[L.X].zoom=e+i:t.altKey?(n[L.X].translate=e,n[L.Y].translate=i):n[L.X].translate=e+i;const s=this.el.getBoundingClientRect(),o={[L.X]:t.clientX-s.left,[L.Y]:t.clientY-s.top};let a=!1;for(const{dir:e,op:i}of U(this.options)){const s=i.scale.domain(),r=D(i.scale),h=n[e],c=i.scale.invert(o[e]);h.translate*=r,h.zoom*=.002,t.shiftKey&&(h.translate*=5,h.zoom*=5);const l=.4*(s[1]-s[0]);h.translate=T(h.translate,-l,l);const d=.5;h.zoom=T(h.zoom,-d,d),S(i,s.map(t=>t+h.translate+(t-c)*h.zoom))&&(a=!0)}a&&this.scaleUpdated.dispatch()}}class O{constructor(t,e){this.el=t,this.options=e,this.scaleUpdated=new o,this.previousPoint=null,t.style.userSelect="none",t.addEventListener("pointerdown",t=>this.onMouseDown(t)),t.addEventListener("pointerup",t=>this.onMouseUp(t)),t.addEventListener("pointermove",t=>this.onMouseMove(t))}point(t){const e=this.el.getBoundingClientRect();return{[L.X]:t.clientX-e.left,[L.Y]:t.clientY-e.top}}onMouseMove(t){if(null===this.previousPoint)return;const e=this.point(t);let i=!1;for(const{dir:t,op:n}of U(this.options)){const s=e[t]-this.previousPoint[t],o=D(n.scale),a=n.scale.domain();S(n,a.map(t=>t-o*s))&&(i=!0)}this.previousPoint=e,i&&this.scaleUpdated.dispatch()}onMouseDown(t){"mouse"===t.pointerType&&(this.el.setPointerCapture(t.pointerId),this.previousPoint=this.point(t),this.el.style.cursor="grabbing")}onMouseUp(t){null!==this.previousPoint&&(this.previousPoint=null,this.el.releasePointerCapture(t.pointerId),this.el.style.cursor="")}}const B={minDomain:-1/0,maxDomain:1/0,minDomainExtent:0,maxDomainExtent:1/0};class j{constructor(t,e){this.scaleUpdated=new o,e=null!=e?e:{},this.options={x:e.x&&Object.assign(Object.assign({},B),e.x),y:e.y&&Object.assign(Object.assign({},B),e.y)},this.touch=new I(t,this.options),this.mouse=new O(t,this.options),this.wheel=new N(t,this.options);const i=()=>this.scaleUpdated.dispatch();this.touch.scaleUpdated.on(i),this.mouse.scaleUpdated.on(i),this.wheel.scaleUpdated.on(i)}onScaleUpdated(t){this.scaleUpdated.on(t)}update(){this.touch.update()}}const Y={lineWidth:1,backgroundColor:t.rgb(255,255,255,1),paddingTop:10,paddingRight:10,paddingLeft:45,paddingBottom:20,xRange:"auto",yRange:"auto",realTime:!1,baseTime:0},z={color:t.rgb(0,0,0,1),name:""};return class{constructor(t,e){var i,n;this.el=t;const s=null!=(n=null===(i=(e=null!=e?e:{}).series)||void 0===i?void 0:i.map(t=>Object.assign(Object.assign({data:[]},z),t)))?n:[],o=Object.assign(Object.assign(Object.assign({},Y),e),{series:s});this.model=new a(o),this.canvasLayer=new P(t,o,this.model),this.svgLayer=new E(t,o,this.model),this.lineChartRenderer=new M(this.model,this.canvasLayer.gl,o),this.options=Object.assign(o,{zoom:this.registerZoom(e.zoom)}),this.onResize(),window.addEventListener("resize",()=>this.onResize())}registerZoom(t){if(t){const e=new j(this.el,{x:t.x&&Object.assign(Object.assign({},t.x),{scale:this.model.xScale}),y:t.y&&Object.assign(Object.assign({},t.y),{scale:this.model.yScale})}),i=e.options;return this.model.updated.on(()=>{var t;const n=[[i.x,this.model.xScale,this.model.xRange],[i.y,this.model.yScale,this.model.yRange]];for(const[e,i,s]of n){if(!(null===(t=e)||void 0===t?void 0:t.autoRange))continue;let[n,o]=i.domain();s&&(n=Math.min(n,s.min),o=Math.max(o,s.max)),e.minDomain=n,e.maxDomain=o}e.update()}),e.onScaleUpdated(()=>{this.options.xRange=null,this.options.yRange=null,this.options.realTime=!1,this.update()}),i}}onResize(){const t=this.canvasLayer.canvas;this.model.resize(t.clientWidth,t.clientHeight),this.svgLayer.onResize(),this.canvasLayer.onResize(),this.lineChartRenderer.onResize(t.clientWidth,t.clientHeight),this.update()}update(){this.model.requestRedraw()}}}));
//# sourceMappingURL=timechart.min.js.map
